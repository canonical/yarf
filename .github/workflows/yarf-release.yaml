name: Release YARF

on:
  pull_request:
  workflow_dispatch:
    inputs:
      from_tag:
        description: "Start boundary tag. Leave empty to use the previous tag before 'to_tag' (or repo start if only one tag exists)."
        type: string
        required: false
        default: ""
      to_tag:
        description: "End boundary tag (release to update). Leave empty to use the latest tag."
        type: string
        required: false
        default: "2.0.1"

permissions:
  contents: write
  pull-requests: read

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          ref: main
          lfs: true
          fetch-depth: 0

      - name: Ensure tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Resolve & validate tags
        id: tags
        env:
          IN_FROM: ${{ github.event.inputs.from_tag }}
          IN_TO:   ${{ github.event.inputs.to_tag }}
        run: |
          set -euo pipefail

          git fetch --tags --force

          # Helper: latest tag by creation date
          latest_tag() {
            git for-each-ref --sort=-creatordate --format='%(refname:strip=2)' refs/tags | head -n1
          }

          # Determine TO_TAG default (latest tag if empty)
          if [ -n "${IN_TO:-}" ]; then
            TO_TAG="${IN_TO}"
          else
            TO_TAG="$(latest_tag || true)"
            if [ -z "${TO_TAG:-}" ]; then
              echo "No tags found in the repository to use as 'to_tag'." >&2
              exit 1
            fi
          fi

          # Verify TO_TAG exists
          git rev-parse -q --verify "refs/tags/${TO_TAG}" >/dev/null || { echo "Tag '${TO_TAG}' not found."; exit 1; }

          # Determine FROM_TAG default:
          # - If provided, use it (and verify)
          # - Else use the previous tag (by creation date) before TO_TAG
          # - If there is no previous tag (only one tag exists), mark as ROOT
          if [ -n "${IN_FROM:-}" ]; then
            FROM_TAG="${IN_FROM}"
            git rev-parse -q --verify "refs/tags/${FROM_TAG}" >/dev/null || { echo "Tag '${FROM_TAG}' not found."; exit 1; }
            FROM_KIND="tag"
          else
            mapfile -t TAGS_ASC < <(git for-each-ref --sort=creatordate --format='%(refname:strip=2)' refs/tags)
            PREV=""
            for i in "${!TAGS_ASC[@]}"; do
              if [ "${TAGS_ASC[$i]}" = "${TO_TAG}" ]; then
                if [ "$i" -gt 0 ]; then PREV="${TAGS_ASC[$((i-1))]}"; fi
                break
              fi
            done
            if [ -n "${PREV}" ]; then
              FROM_TAG="${PREV}"
              FROM_KIND="tag"
            else
              FROM_TAG=""   # special: repo start
              FROM_KIND="root"
            fi
          fi

          echo "from=${FROM_TAG}"      >> "$GITHUB_OUTPUT"
          echo "from_kind=${FROM_KIND}" >> "$GITHUB_OUTPUT"
          echo "to=${TO_TAG}"          >> "$GITHUB_OUTPUT"

      - name: Compute time window from ${{ steps.tags.outputs.from }} to ${{ steps.tags.outputs.to }}
        id: window
        run: |
          set -euo pipefail
          FROM="${{ steps.tags.outputs.from }}"
          FROM_KIND="${{ steps.tags.outputs.from_kind }}"
          TO="${{ steps.tags.outputs.to }}"

          if [ "${FROM_KIND}" = "tag" ]; then
            SINCE="$(git log -1 --format=%cI "${FROM}")"
            NOTE_FROM="\\\`${FROM}\\\`"
          else
            ROOT="$(git rev-list --max-parents=0 HEAD | tail -n1)"
            SINCE="$(git log -1 --format=%cI "${ROOT}")"
            NOTE_FROM="repository start"
          fi
          UNTIL="$(git log -1 --format=%cI "${TO}")"

          if [ "$(date -u -d "$SINCE" +%s)" -ge "$(date -u -d "$UNTIL" +%s)" ]; then
            echo "Warning: from boundary is not earlier than to boundary; notes may be empty." >&2
          fi

          echo "since=${SINCE}" >> "$GITHUB_OUTPUT"
          echo "until=${UNTIL}" >> "$GITHUB_OUTPUT"
          echo "note_from=${NOTE_FROM}" >> "$GITHUB_OUTPUT"

      - name: Collect commits between tags (lower exclusive, upper inclusive)
        id: commits
        run: |
          set -euo pipefail
          FROM_KIND="${{ steps.tags.outputs.from_kind }}"
          FROM="${{ steps.tags.outputs.from }}"
          TO="${{ steps.tags.outputs.to }}"

          if [ "${FROM_KIND}" = "tag" ] && [ -n "${FROM}" ]; then
            RANGE="${FROM}..${TO}"
          else
            # Only one tag exists: take full history reachable from TO
            RANGE="${TO}"
          fi

          # Fields: fullSHA<TAB>shortSHA<TAB>authorName<TAB>subject
          git log --pretty=format:'%H%x09%h%x09%an%x09%s' ${RANGE} > commits.tsv || true

          # Ensure file exists even if empty
          [ -s commits.tsv ] || : > commits.tsv

      - name: Build release body
        id: body
        env:
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          awk -F '\t' -v REPO="$REPO" '
            BEGIN{
              breaking=""; new=""; bugfix=""; infra="";
            }
            {
              sha=$1; short=$2; author=$3; title=$4;

              # Determine category by prefix (case-insensitive)
              low=title; gsub(/[A-Z]/, "", low); # quick lowercase copy is messy in awk; match case-insensitively instead
              cat="";
              if (title ~ /^\[Breaking\]/i) cat="breaking";
              else if (title ~ /^\[New\]/i) cat="new";
              else if (title ~ /^\[BugFix\]/i) cat="bugfix";
              else if (title ~ /^\[Infra\]/i) cat="infra";
              else next;  # ignore lines without one of the four prefixes (add an "Other" section if you want)

              # Strip the prefix for display
              gsub(/^\[(Breaking|New|BugFix|Infra)\][[:space:]]*/,"",title);

              line="- " title " ([" short "](https://github.com/" REPO "/commit/" sha ")) by " author;

              if (cat=="breaking") breaking=breaking line ORS;
              else if (cat=="new") new=new line ORS;
              else if (cat=="bugfix") bugfix=bugfix line ORS;
              else if (cat=="infra") infra=infra line ORS;
            }
            END{
              print "## Changes";
              if (breaking!="") { print "\n### Breaking Changes";      printf "%s", breaking; }
              if (new!="")      { print "\n### New";                   printf "%s", new; }
              if (bugfix!="")   { print "\n### Bug Fixes";             printf "%s", bugfix; }
              if (infra!="")    { print "\n### Infrastructure";        printf "%s", infra; }
            }
          ' commits.tsv > sections.md

          {
            echo "# Release ${{ steps.tags.outputs.to }}"
            echo
            echo "> Changes after ${{ steps.window.outputs.note_from }} and up to and including \`${{ steps.tags.outputs.to }}\`."
            echo
            cat sections.md
          } > release_body.md

          cat release_body.md
          echo "path=release_body.md" >> "$GITHUB_OUTPUT"

      - name: Write release body to job summary
        run: |
          {
            echo "# Release Notes Preview"
            echo
            echo "**From:** ${{ steps.window.outputs.note_from }}  "
            echo "**To:** \`${{ steps.tags.outputs.to }}\`"
            echo
            cat release_body.md
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update GitHub Release ${{ steps.tags.outputs.to }}
        if: ${{ github.event_name == 'workflow_dispatch' }}  # prevent on PR runs, adjust as you like
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.tags.outputs.to }}"
          NOTES_FILE="${{ steps.body.outputs.path }}"
          # gh release create "${TAG}" --title "${TAG}" --notes-file "${NOTES_FILE}" || \
          # gh release edit   "${TAG}" --notes-file "${NOTES_FILE}"
