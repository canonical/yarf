name: Release Notes

on:
  pull_request:
  workflow_dispatch:
    inputs:
      from_tag:
        description: "Start boundary tag. Leave empty to use the previous tag before 'to_tag' (or repo start if only one tag exists)."
        type: string
        required: false
        default: ""
      to_tag:
        description: "End boundary tag (release to update). Leave empty to use the latest tag."
        type: string
        required: false
        default: "2.0.1"

permissions:
  contents: write
  pull-requests: read

jobs:
  release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          ref: main
          lfs: true
          fetch-depth: 0

      - name: Ensure tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Resolve & validate tags
        id: tags
        env:
          IN_FROM: ${{ github.event.inputs.from_tag }}
          IN_TO:   ${{ github.event.inputs.to_tag }}
        run: |
          set -euo pipefail

          git fetch --tags --force

          # Helper: latest tag by creation date
          latest_tag() {
            git for-each-ref --sort=-creatordate --format='%(refname:strip=2)' refs/tags | head -n1
          }

          # Determine TO_TAG default (latest tag if empty)
          if [ -n "${IN_TO:-}" ]; then
            TO_TAG="${IN_TO}"
          else
            TO_TAG="$(latest_tag || true)"
            if [ -z "${TO_TAG:-}" ]; then
              echo "No tags found in the repository to use as 'to_tag'." >&2
              exit 1
            fi
          fi

          # Verify TO_TAG exists
          git rev-parse -q --verify "refs/tags/${TO_TAG}" >/dev/null || { echo "Tag '${TO_TAG}' not found."; exit 1; }

          # Determine FROM_TAG default:
          # - If provided, use it (and verify)
          # - Else use the previous tag (by creation date) before TO_TAG
          # - If there is no previous tag (only one tag exists), mark as ROOT
          if [ -n "${IN_FROM:-}" ]; then
            FROM_TAG="${IN_FROM}"
            git rev-parse -q --verify "refs/tags/${FROM_TAG}" >/dev/null || { echo "Tag '${FROM_TAG}' not found."; exit 1; }
            FROM_KIND="tag"
          else
            # Build ascending list by creation date
            mapfile -t TAGS_ASC < <(git for-each-ref --sort=creatordate --format='%(refname:strip=2)' refs/tags)
            PREV=""
            for i in "${!TAGS_ASC[@]}"; do
              if [ "${TAGS_ASC[$i]}" = "${TO_TAG}" ]; then
                if [ "$i" -gt 0 ]; then PREV="${TAGS_ASC[$((i-1))]}"; fi
                break
              fi
            done
            if [ -n "${PREV}" ]; then
              FROM_TAG="${PREV}"
              FROM_KIND="tag"
            else
              FROM_TAG=""   # special: repo start
              FROM_KIND="root"
            fi
          fi

          echo "from=${FROM_TAG}"   >> "$GITHUB_OUTPUT"
          echo "from_kind=${FROM_KIND}" >> "$GITHUB_OUTPUT"
          echo "to=${TO_TAG}"       >> "$GITHUB_OUTPUT"

      - name: Compute time window from ${{ steps.tags.outputs.from }} to ${{ steps.tags.outputs.to }}
        id: window
        run: |
          set -euo pipefail
          FROM="${{ steps.tags.outputs.from }}"
          FROM_KIND="${{ steps.tags.outputs.from_kind }}"
          TO="${{ steps.tags.outputs.to }}"

          if [ "${FROM_KIND}" = "tag" ]; then
            SINCE="$(git log -1 --format=%cI "${FROM}")"
            NOTE_FROM="\\\`${FROM}\\\`"
          else
            ROOT="$(git rev-list --max-parents=0 HEAD | tail -n1)"
            SINCE="$(git log -1 --format=%cI "${ROOT}")"
            NOTE_FROM="repository start"
          fi
          UNTIL="$(git log -1 --format=%cI "${TO}")"

          if [ "$(date -u -d "$SINCE" +%s)" -ge "$(date -u -d "$UNTIL" +%s)" ]; then
            echo "Warning: from boundary is not earlier than to boundary; notes may be empty." >&2
          fi

          echo "since=${SINCE}" >> "$GITHUB_OUTPUT"
          echo "until=${UNTIL}" >> "$GITHUB_OUTPUT"
          echo "note_from=${NOTE_FROM}" >> "$GITHUB_OUTPUT"

      - name: Collect merged PRs from ${{ steps.window.outputs.since }} to ${{ steps.window.outputs.until }}
        id: prs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          SINCE="${{ steps.window.outputs.since }}"
          UNTIL="${{ steps.window.outputs.until }}"

          # Grab PRs merged in (SINCE, UNTIL] with fields we need
          gh pr list --state merged \
            --search "merged:>${SINCE} merged:<=${UNTIL}" \
            --limit 200 \
            --json number,title,mergedAt,author,url \
          | jq 'map({
                number,
                title,
                mergedAt,
                author: (.author.login // "unknown"),
                url
              })
              | sort_by(.mergedAt) | reverse' \
          > prs.json

          if [ ! -s prs.json ] || [ "$(jq length prs.json)" -eq 0 ]; then
            echo '[]' > prs.json
          fi

      - name: Build release body
        id: body
        run: |
          set -euo pipefail
          jq -r '
            def cat:
              if (.title|test("^\\[Breaking\\]"; "i")) then "Breaking"
              elif (.title|test("^\\[New\\]"; "i")) then "New"
              elif (.title|test("^\\[BugFix\\]"; "i")) then "BugFix"
              elif (.title|test("^\\[Infra\\]"; "i")) then "Infra"
              else null end;

            def clean_title:
              .title
              | sub("^\\[(Breaking|New|BugFix|Infra)\\]\\s*"; "");

            def line:
              "- " + (clean_title)
              + " ([#" + (.number|tostring) + "](" + .url + "))"
              + " by @" + .author;

            . as $all
            | def section($label; $key):
                ([$all[] | select(cat == $key) | line]) as $lines
                | if ($lines|length) > 0
                  then "\n### " + $label + "\n" + ($lines | join("\n"))
                  else "" end;

            "## Changes"
            + section("Breaking Changes";           "Breaking")
            + section("New";                        "New")
            + section("Bug Fixes";                  "BugFix")
            + section("Infrastructural Changes";    "Infra")
          ' prs.json > sections.md

          {
            echo "# Release ${{ steps.tags.outputs.to }}"
            echo
            echo "> Changes merged after ${{ steps.window.outputs.note_from }} and up to and including \`${{ steps.tags.outputs.to }}\`."
            echo
            cat sections.md
          } > release_body.md

          echo "path=release_body.md" >> "$GITHUB_OUTPUT"

      - name: Write release body to job summary
        run: |
          {
            echo "## Release Notes Preview"
            echo
            echo "**From:** ${{ steps.window.outputs.note_from }}  "
            echo "**To:** \`${{ steps.tags.outputs.to }}\`"
            echo
            cat release_body.md
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update GitHub Release for ${{ steps.tags.outputs.to }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.tags.outputs.to }}"
          NOTES_FILE="${{ steps.body.outputs.path }}"
          # gh release create "${TAG}" --title "${TAG}" --notes-file "${NOTES_FILE}" || \
          # gh release edit   "${TAG}" --notes-file "${NOTES_FILE}"
