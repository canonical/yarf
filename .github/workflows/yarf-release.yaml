name: Release YARF

on:
  pull_request:
  workflow_dispatch:
    inputs:
      from_tag:
        description: "Start boundary tag. Leave empty to use the previous tag before 'to_tag' (or repo start if only one tag exists)."
        type: string
        required: false
        default: ""
      to_tag:
        description: "End boundary tag (release to update). Leave empty to use the latest tag."
        type: string
        required: false
        default: "2.0.1"

permissions:
  contents: write
  pull-requests: read

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          ref: main
          lfs: true
          fetch-depth: 0

      - name: Ensure tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Resolve & validate tags
        id: tags
        env:
          IN_FROM: ${{ github.event.inputs.from_tag }}
          IN_TO:   ${{ github.event.inputs.to_tag }}
        run: |
          set -euo pipefail

          git fetch --tags --force

          # Helper: latest tag by creation date
          latest_tag() {
            git for-each-ref --sort=-creatordate --format='%(refname:strip=2)' refs/tags | head -n1
          }

          # Determine TO_TAG default (latest tag if empty)
          if [ -n "${IN_TO:-}" ]; then
            TO_TAG="${IN_TO}"
          else
            TO_TAG="$(latest_tag || true)"
            if [ -z "${TO_TAG:-}" ]; then
              echo "No tags found in the repository to use as 'to_tag'." >&2
              exit 1
            fi
          fi

          git rev-parse -q --verify "refs/tags/${TO_TAG}" >/dev/null || { echo "Tag '${TO_TAG}' not found."; exit 1; }

          # Determine FROM_TAG default:
          # - If provided, use it (and verify)
          # - Else use the previous tag (by creation date) before TO_TAG
          # - If there is no previous tag (only one tag exists), mark as ROOT
          if [ -n "${IN_FROM:-}" ]; then
            FROM_TAG="${IN_FROM}"
            git rev-parse -q --verify "refs/tags/${FROM_TAG}" >/dev/null || { echo "Tag '${FROM_TAG}' not found."; exit 1; }
            FROM_KIND="tag"
          else
            mapfile -t TAGS_ASC < <(git for-each-ref --sort=creatordate --format='%(refname:strip=2)' refs/tags)
            PREV=""
            for i in "${!TAGS_ASC[@]}"; do
              if [ "${TAGS_ASC[$i]}" = "${TO_TAG}" ]; then
                if [ "$i" -gt 0 ]; then PREV="${TAGS_ASC[$((i-1))]}"; fi
                break
              fi
            done
            if [ -n "${PREV}" ]; then
              FROM_TAG="${PREV}"
              FROM_KIND="tag"
            else
              FROM_TAG=""   # special: repo start
              FROM_KIND="root"
            fi
          fi

          echo "from=${FROM_TAG}"       >> "$GITHUB_OUTPUT"
          echo "from_kind=${FROM_KIND}" >> "$GITHUB_OUTPUT"
          echo "to=${TO_TAG}"           >> "$GITHUB_OUTPUT"

      - name: Compute boundaries
        id: bounds
        run: |
          set -euo pipefail
          FROM="${{ steps.tags.outputs.from }}"
          FROM_KIND="${{ steps.tags.outputs.from_kind }}"
          TO="${{ steps.tags.outputs.to }}"

          if [ "${FROM_KIND}" = "tag" ]; then
            FROM_SHA="$(git rev-list -n 1 "${FROM}")"   # lower bound (exclusive)
            NOTE_FROM="\\\`${FROM}\\\`"
          else
            FROM_SHA=""                                 # walk until history ends
            NOTE_FROM="repository start"
          fi
          TO_SHA="$(git rev-list -n 1 "${TO}")"

          echo "from_sha=${FROM_SHA}" >> "$GITHUB_OUTPUT"
          echo "to_sha=${TO_SHA}"     >> "$GITHUB_OUTPUT"
          echo "note_from=${NOTE_FROM}" >> "$GITHUB_OUTPUT"

      - name: Collect commits
        id: commits
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          FROM_SHA="${{ steps.bounds.outputs.from_sha }}"
          TO="${{ steps.tags.outputs.to }}"

          : > pages.json
          PAGE=1
          while true; do
            RESP="$(mktemp)"
            gh api "repos/${REPO}/commits" \
              -F sha="${TO}" \
              -F per_page=100 \
              -F page="${PAGE}" \
              > "$RESP" || { cat "$RESP" || true; rm -f "$RESP"; exit 1; }

            COUNT=$(jq 'length' "$RESP")
            if [ "$COUNT" -eq 0 ]; then rm -f "$RESP"; break; fi

            if [ -n "${FROM_SHA}" ]; then
              IDX=$(jq -r --arg from "$FROM_SHA" 'map(.sha) | index($from) // -1' "$RESP")
              if [ "$IDX" -ge 0 ]; then
                # take items only BEFORE from_sha (exclusive lower bound)
                jq --argjson idx "$IDX" '
                  .[0:$idx]
                  | map({
                      sha: .sha,
                      short: (.sha[0:7]),
                      url: .html_url,
                      title: (.commit.message | split("\n")[0]),
                      author_login: (.author.login // null),
                      author_name:  (.commit.author.name // null),
                      committedAt:  .commit.author.date
                    })
                ' "$RESP" >> pages.json
                rm -f "$RESP"
                break
              else
                jq '
                  map({
                    sha: .sha,
                    short: (.sha[0:7]),
                    url: .html_url,
                    title: (.commit.message | split("\n")[0]),
                    author_login: (.author.login // null),
                    author_name:  (.commit.author.name // null),
                    committedAt:  .commit.author.date
                  })
                ' "$RESP" >> pages.json
              fi
            else
              jq '
                map({
                  sha: .sha,
                  short: (.sha[0:7]),
                  url: .html_url,
                  title: (.commit.message | split("\n")[0]),
                  author_login: (.author.login // null),
                  author_name:  (.commit.author.name // null),
                  committedAt:  .commit.author.date
                })
              ' "$RESP" >> pages.json
            fi

            rm -f "$RESP"
            PAGE=$((PAGE+1))
          done

          if [ -s pages.json ]; then
            jq -s 'add | sort_by(.committedAt) | reverse' pages.json > commits.json
          else
            echo "[]" > commits.json
          fi

      - name: Build release body
        id: body
        run: |
          set -euo pipefail
          jq -r '
            def category:
              if (.title|test("^\\[Breaking\\]";"i")) then "Breaking"
              elif (.title|test("^\\[New\\]";"i")) then "New"
              elif (.title|test("^\\[BugFix\\]";"i")) then "BugFix"
              elif (.title|test("^\\[Infra\\]";"i")) then "Infra"
              else null end;

            def clean_title:
              .title | sub("^\\[(Breaking|New|BugFix|Infra)\\]\\s*"; "");

            def author:
              if .author_login then "@" + .author_login
              elif .author_name then .author_name
              else "unknown" end;

            def line:
              "- " + (clean_title)
              + " ([" + .short + "](" + .url + "))"
              + " by " + (author);

            . as $all
            | def section($label; $key):
                ([$all[] | select(category == $key) | line]) as $lines
                | if ($lines|length) > 0
                  then "\n### " + $label + "\n" + ($lines | join("\n"))
                  else "" end;

            "## Changes"
            + section("Breaking Changes"; "Breaking")
            + section("New";               "New")
            + section("Bug Fixes";         "BugFix")
            + section("Infrastructure";    "Infra")
          ' commits.json > sections.md

          {
            echo "# Release ${{ steps.tags.outputs.to }}"
            echo
            echo "> Changes after ${{ steps.bounds.outputs.note_from }} and up to and including \`${{ steps.tags.outputs.to }}\`."
            echo
            cat sections.md
          } > release_body.md

          cat release_body.md
          echo "path=release_body.md" >> "$GITHUB_OUTPUT"

      - name: Write release body to job summary
        run: |
          {
            echo "# Release Notes Preview"
            echo
            echo "**From:** ${{ steps.bounds.outputs.note_from }}  "
            echo "**To:** \`${{ steps.tags.outputs.to }}\`"
            echo
            cat release_body.md
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update GitHub Release ${{ steps.tags.outputs.to }}
        if: ${{ github.event_name == 'workflow_dispatch' }}  # prevent on PR runs, adjust as you like
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.tags.outputs.to }}"
          NOTES_FILE="${{ steps.body.outputs.path }}"
          # gh release create "${TAG}" --title "${TAG}" --notes-file "${NOTES_FILE}" || \
          # gh release edit   "${TAG}" --notes-file "${NOTES_FILE}"
