name: YARF snap promotion

on:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  actions: write

concurrency:
  group: promote-yarf-${{ github.ref }}
  cancel-in-progress: true

jobs:
  define-matrix:
    name: Define job matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.out.outputs.matrix }}
    steps:
      - id: out
        shell: bash
        run: |
          cat > matrix.json <<'JSON'
          {
            "track": ["latest"],
            "arch":  ["amd64","arm64"],
            "lane":  ["edge_to_beta"],
            "include": [
              {
                "arch": "amd64",
                "runs_on": ["self-hosted","linux","noble","x64","large"],
                "snap_arch": "amd64"
              },
              {
                "arch": "arm64",
                "runs_on": ["self-hosted","linux","noble","arm64","large"],
                "snap_arch": "arm64"
              },
              {
                "lane": "edge_to_beta",
                "from": "edge",
                "to":   "beta",
                "test_workflow": "run_canary_test.yaml"
              }
            ]
          }
          JSON
          {
            echo "matrix<<EOF"
            cat matrix.json
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # check-versions:
  #   name: ${{ matrix.track }} / ${{ matrix.arch }} — ${{ matrix.from }} to ${{ matrix.to }}
  #   runs-on: ${{ fromJSON(matrix.runs_on) }}
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       track: [latest]
  #       arch:  [amd64, arm64]
  #       lane:  [edge_to_beta]
  #       include:
  #         - arch: amd64
  #           runs_on: '["self-hosted","linux","noble","x64","large"]'
  #           snap_arch: amd64
  #         - arch: arm64
  #           runs_on: '["self-hosted","linux","noble","arm64","large"]'
  #           snap_arch: arm64

  #         - lane: edge_to_beta
  #           from: edge
  #           to: beta
  #           test_workflow: run_canary_test.yaml

  #   env:
  #     SNAP_NAME: yarf
  #     TRACK: ${{ matrix.track }}
  #     ARCH: ${{ matrix.arch }}
  #     SNAP_ARCH: ${{ matrix.snap_arch }}
  #     FROM: ${{ matrix.from }}
  #     TO: ${{ matrix.to }}
  #     TEST_WORKFLOW: ${{ matrix.test_workflow }}
  #     SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT }}

  #   outputs:
  #     should_continue: ${{ steps.versions.outputs.should_continue }}
  #     from_revision:   ${{ steps.versions.outputs.from_revision }}
  #     from_channel:    ${{ steps.versions.outputs.from_channel }}

  #   steps:
  #     - name: Context
  #       shell: bash
  #       run: |
  #         echo "Track: ${TRACK}"
  #         echo "Arch:  ${ARCH} (snap_arch=${SNAP_ARCH})"
  #         echo "Lane:  ${FROM} --> ${TO}"
  #         echo "Tests: ${TEST_WORKFLOW}"

  #     - name: Get versions in ${{ env.TRACK }}/${{ env.FROM }} and ${{ env.TRACK }}/${{ env.TO }}
  #       id: versions
  #       shell: bash
  #       run: |
  #         set -euo pipefail
  #         echo "Fetching channel info for ${SNAP_NAME}..."

  #         snap info "${SNAP_NAME}" \
  #         | awk '/^[[:space:]]*[[:alnum:].-]+\/(edge|beta|candidate|stable):/ {
  #             gsub(":","",$1)
  #             ver=$2
  #             rev=""
  #             if (match($0, /\(([0-9]+)\)/, m)) rev=m[1]
  #             print $1, ver, rev
  #           }' > channels.txt || true

  #         echo "Channel map (channel version revision):"
  #         cat channels.txt || true

  #         FROM_VER=$(awk -v t="${TRACK}/${FROM}" '$1==t{print $2}' channels.txt || true)
  #         TO_VER=$(awk -v t="${TRACK}/${TO}"   '$1==t{print $2}' channels.txt || true)

  #         FROM_REV=$(awk -v t="${TRACK}/${FROM}" '$1==t{print $3}' channels.txt || true)
  #         TO_REV=$(awk -v t="${TRACK}/${TO}"   '$1==t{print $3}' channels.txt || true)

  #         if [[ -z "${FROM_VER:-}" ]]; then
  #           echo "No version found in ${TRACK}/${FROM}."
  #           exit 1
  #         fi

  #         # change to <= after testing CI
  #         if [[ -n "${TO_VER:-}" && "$FROM_VER" < "$TO_VER" ]]; then
  #           echo "Versions match ($FROM_VER) in ${TRACK} (${FROM} vs ${TO}). Nothing to do."
  #           echo "should_continue=false" >> "$GITHUB_OUTPUT"
  #         else
  #           echo "Version in ${FROM}=$FROM_VER (rev $FROM_REV) > ${TO}=$TO_VER (rev ${TO_REV:-none}) in ${TRACK}."
  #           echo "${FROM} revision is $FROM_REV"
  #           echo "should_continue=true" >> "$GITHUB_OUTPUT"
  #           echo "from_revision=$FROM_REV" >> "$GITHUB_OUTPUT"
  #           echo "from_channel=${TRACK}/${FROM}" >> "$GITHUB_OUTPUT"
  #         fi

  # canary:
  #   name: Canary — ${{ matrix.track }} / ${{ matrix.arch }} — ${{ matrix.from }}
  #   needs: check-versions
  #   if: needs.check-versions.outputs.should_continue == 'true'
  #   strategy:
  #     fail-fast: false
  #     matrix: *promo_matrix
  #   uses: ./.github/workflows/run_canary_test.yaml
  #   with:
  #     NAME:    yarf
  #     TRACK:   ${{ matrix.track }}
  #     CHANNEL: ${{ matrix.from }}
  #     REV:     ${{ needs.check-versions.outputs.from_revision }}
  #     ARCH:    ${{ matrix.arch }}
  #     MACHINE_TYPE: ${{ matrix.runs_on }}
